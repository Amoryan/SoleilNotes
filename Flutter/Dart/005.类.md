## 1 简介
Dart 是一个面向对象编程语言，每个对象都是一个类的实例，类都继承于 `Object`。
```dart
class Point {
   //自动生成一个 getter 方法（隐含的）。 非final 实例变量还会自动生成一个 setter 方法。
   num x;
   num y;
}
```
## 2 构造函数
```dart
class Point {
   num x;
   num y;
  
   Point(num x, num y) {      
      this.x = x;
      this.y = y;
   }
   //可以简化
   Point(this.x,this.y);
}
```

## 3 命名构造函数
Dart 不支持构造函数的重载，使用命名构造函数为一个类实现多个构造函数。
```dart
class Point {
   num x;
   num y;
  
   Point(this.x,this.y);
   Point.y(this.y){
     x = 0;
   }  
}   
//使用
var p = Ponit.y(1)

```
## 4 初始化列表
```dart
class Point {
   num x;
   num y;
  
   Point(this.x,this.y);
   
   //初始化列表在构造函数运行前设置实例变量。
   Point.fromMap(Map json)
      :x = map['x'];
	   y = map['y'];
     
}   
//使用
var p = Ponit(1)

```
## 5 静态构造函数
类产生的对象永远不会改变，让这些对象成为编译时常量。
```dart
class Point{
  final num x;
  final num y;
  const Point(this.x,this.y);
  static final var origin = const Point(0,0);

}

```

## 6 重定向构造函数
重定向到该类的另一个构造函数
```dart
class Point {
    num x;
    num y;

    //主构造函数
    Point(this.x, this.y) {
        print("Point($x, $y)");
    }

    //重定向构造函数，指向主构造函数，函数体为空
    Point.alongXAxis(num x) : this(x, 0);
}

void main() {
    var p1 = new Point(1, 2);
    var p2 = new Point.alongXAxis(4);
}

```

## 7 工厂构造函数
使用 factory 关键词修饰的构造函数时，这个构造函数不必创建类的新实例。
```dart
class Logger {
   final String name;
   bool mute = false;

   // _cache 是一个私有库,名字前有个 _ 。 
   static final Map<String, Logger> _cache = <String, Logger>{};

   factory Logger(String name) {
       if (_cache.containsKey(name)) {
          return _cache[name];
       } else {
          final logger = new Logger._internal(name);
		  //工厂构造函数需要返回 Logger 实例对象
          _cache[name] = logger;
          return logger;
       }
    }

   ////以 _ 开头的函数、变量无法在库外使用
    Logger._internal(this.name);

    void log(String msg) {
       if (!mute) {
          print(msg);
       }
    }
    
 }


```
借助工厂构造函数实现单例。
```dart
class Manager {
  static Manager _instance;
  factory Manager.getInstance() {
     if(_instance == null){
	     _instance = Manager._internal;
	 }
	 return _instance;
  }
  Manager._internal;
}

```

## 8 Getters 和 Setters
Dart 每个实例变量都隐含的具有一个 getter，如果变量不是 final 还有一个 setter，可以通过实现 getter 和 setter 来创建新的属性。
```dart
class Rect {
   num left;
   num top;
   num width;
   num height;
   Rect(this.left,this.top,this.width,this.height);
   
   num get right => left + width;
   set right(num value) => left = value - width;  
}

void main(){
  var p = Point(1,2,3,4);
  var right = p.right //4
}
```

## 9 抽象类
使用 `abstract` 修饰符定义一个抽象类，抽象类中允许出现无方法体的方法。
```dart
abstract class Person {
  String name;
  void printName();

}

```
抽象类不能被实例化，但是可以定义工厂方法并返回子类。
```dart
abstract class Parent {
  String name;
  //默认构造方法
  Parent(this.name);
  //工厂方法返回Child实例
  factory Parent.test(String name){
    return new Child(name);
  }
  void printName();
}
//extends 继承抽象类
class Child extends Parent{
  Child(String name) : super(name);

  @override
  void printName() {
    print(name);
  }
}

void main() {
  var p = Parent.test("test");
  print(p.runtimeType); //输出类型 Child
  p.printName();		
}


```

## 9 类-隐式接口
每个类隐式的定义了一个接口，含有类的所有实例和它实现的所有接口。
```dart
class Person {
  final _name;

  Person(this._name);

  String greet(who) => "$who";
}

class Son implements Person {
  @override
  get _name => "";

  @override
  String greet(who) => "$who";
}




```

## 10 类-继承
使用 extends 创建一个子类，同时 supper 将指向父类。
```dart
class Child extends Person{
  Child(name) : super(name);
}
```

## 11 可调用的类
类实现了 `call()` 函数,则可以当做方法来调用。
```dart
class Closure {
  call(String a, String b) => '$a $b';
}

void main() {
  var c = new Closure();
  var out = c("Hello","Dart");
  print(out);
}
```

## 12 混合mixins
多类继承中重用一个类代码的方法，被mixin(混入)的类不能有构造函数。
```dart
class A {
  void a() {}

  String getMessage() => "TEST_A";
}

class B {
  void b() {}

  //和 A 同名方法
  String getMessage() => "TEST_B";
}

class P {
  String getMessage() => "TEST_P";
}

class AB with A, B {}
class BA with B, A {}

//继承与mixins是兼容的
class PAB estends P with B, A {}
//简化
class PAB = P with A, B;


void printMessage(obj) => print(obj.getMessage());
void main(){
  //假设A与B 存在相同的方法，以最右侧的混入类为主
  printMessage(AB()); //TEST_B
  printMessage(BA()); //TEST_A
  
  printMessage(PAB()); //TEST_B
}


```
mixins 弥补了接口和继承的不足，继承只能单继承，而接口无法复用实现。



