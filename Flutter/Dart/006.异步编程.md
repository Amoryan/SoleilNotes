## 1 isolate 机制
Dart 语言中使用的并发机制，叫做 isolate 机制，不同于 Android 中的中线程，isolate 无法共享内存。Dart 是事件驱动，也有自己的Event Loop。

## 2 Event Loop
有两个队列，分别为微服务队列（Microtask queue），事件队列（Event queue）。
* 事件队列：包含外部事件，例如 I/O、Timer、绘制事件。
* 微服务队列：Dart 内部微服务，通过 scheduleMicrotask 来调度。

![](../../pic/Event-Loop.png)

1. 先检查 Microtask queue是否为空，不为空，执行 MicroTask。
2. 如果 Microtask queue 为空，判断 Event queue 是否为空，不为空执行 Event
3. 每执行完一个 Event，就检查 Microtask queue，如此循环。

由上面可知，Microtask queue 优先级比较高，可以利用微服务来进行插队。

## 3 异步支持
Dart 异步支持常使用的特性是async 方法和 await 表达式。Dart 库大多方法返回 Future 和 Stream 对象，这些方法是异步的，在设置耗时操作（比如 I/O 操作）之后返回，无需等待操作完成。

## 4 异步任务调度
有两种方式，通过 dart:async 这个库的API。
### 4.1 将任务添加到 Microtask queue
```dart
import  'dart:async';

void  myTask(){
    print("this is my task");
}

void  main() {
    //1.使用 scheduleMicrotask 方法添加
    scheduleMicrotask(myTask);

    //2.使用 Future
    Future.microtask(myTask);
}
```

### 4.2 将任务添加到 Event queue　
```dart
import  'dart:async';

void  myTask(){
    print("this is my task");
}

void  main() {
    
    //1.使用 Future
    Future.microtask(myTask);
}
```

## 5 Future
通常异步函数返回的对象是 Future，表示在事件队列中的处理一个事件的结果。使用 `then()` 来在 future 完成的时候执行其他代码。
```dart
void main(){
  Future(()=>getName())
         .then((m)=>"result:${m}")
		 .then((m) => {print(m)})
		 .catchError((e, s) {
             print(s); //异常处理
         }
		 .whenComplete(() => whenTaskCompelete);  //当所有任务完成后的回调函数

}

String getName() => "V1.0.0";

void whenTaskCompelete() => print("任务完成");


Future.delayed(const Duration(seconds: 1), () => getName); //延时任务
```

## 6 async/await
从Dart 1.9开始，Dart添加了async、await关键字实现异步的功能,当我们需要获得A的结果，再执行 B，需要使用 .then().then() 这种回调地狱，利用`async`与`await` 则可以避免。

```dart
Future<String>  getName() async => 'V1.0.1';


Future<String> getName() async {
  //await 等待future执行完成再执行后续代码
  String name = await getNameFromNet();
  return name;
}

Future getNameFromNet() async => "V1.1.0";

```