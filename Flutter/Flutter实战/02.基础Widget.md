## 1 简介

Flutter中⼏乎所有的对象都是⼀个 **Widget**。

Widget：描述⼀个UI元素的配置数据。

* Widget 实际上就是 Element 的配置数据，Widget 树实际上是⼀个配置树，⽽真正的 UI 渲染树是由 Element构成；
* ⼀个 Widget 对象可以对应多个 Element 对象。这很好理解，根据同⼀份配置（Widget），可以创建多个实例 （Element）。 

```dart
@immutable 
abstract class Widget extends DiagnosticableTree {//诊断树，提供调试信息。
    const Widget({ this.key }); 
    final Key key;//是否在下⼀次 build 时复⽤旧的widget,条件在 canUpdate()
    
    @protected
    Element createElement(); //隐式调⽤ 
    
    @override 
    String toStringShort() { 
        return key == null ? '$runtimeType' : '$runtimeType-$key'; 
    }
    
    @override 
    void debugFillProperties(DiagnosticPropertiesBuilder properties) { //诊断树的⼀些特性
        super.debugFillProperties(properties); 
        properties.defaultDiagnosticsTreeStyle = DiagnosticsTreeStyle.dense; 
    }
    //⽤于在Widget树重新 build 时复⽤旧的widget
    static bool canUpdate(Widget oldWidget, Widget newWidget) { 
        return oldWidget.runtimeType == newWidget.runtimeType 
            && oldWidget.key == newWidget.key; 
    } 
}
```

## 2 Stateless Widget

继承⾃ Widget ，重写 createElement() ⽅法。

```dart
@override 
StatelessElement createElement() => new StatelessElement(this);
```

例子

```dart
class Echo extends StatelessWidget { 
    const Echo({ 
        Key key, 
        @required this.text, 
        this.backgroundColor:Colors.grey, 
       }):super(key:key); 
    
    final String text; 
    final Color backgroundColor;
    @override 
    Widget build(BuildContext context) { 
        return Center( 
            child: Container( 
                color: backgroundColor, 
                child: Text(text),
            ), 
        );
    } 
  }
```

## 3 Stateful Widget

继承⾃ widget 类，并重写了 createElement() ⽅法，添加了⼀个新的接⼝ createState() 。

```dart
abstract class StatefulWidget extends Widget { 
    const StatefulWidget({ Key key }) : super(key: key); 
    
    @override
    StatefulElement createElement() => new StatefulElement(this); 
    
    @protected 
    State createState(); 
}
```

## 4 State

⼀个 StatefulWidget 类会对应⼀个State类，State 表示与其对应的 StatefulWidget 要维护的状态。

* 在 widget build 时可以被同步读取。 
* 当 State 被改变时，⼿动调⽤其 setState() ，重新调⽤其 build ⽅法重新构建widget树，更新 UI 的目的。

## 5 State 生命周期

* initState：当Widget第⼀次插⼊到Widget树时会被调⽤，在 build（） ⽅法或 didChangeDependencies() 中 

  调⽤它。

* didChangeDependencies()：当 State 对象的依赖发⽣变化时会被调用。

* build()：

  * 在调⽤ initState() 之后。 
  * 在调⽤ didUpdateWidget() 之后。
  * 在调⽤ setState() 之后。
  * 在调⽤ didChangeDependencies() 之后。
  * 在State对象从树中⼀个位置移除后（会调⽤deactivate）⼜重新插⼊到树的其它位置之后。

* reassemble()：专⻔为了开发调试⽽提供的。

* didUpdateWidget() ：在widget重新构建时，如果 Widget.canUpdate 返回 true 则会调⽤。

* deactivate()：当State对象从树中被移除时，会调⽤此回调。

* dispose() ：当State对象从树中被永久移除时调⽤，通常在此回调中释放资源。

## 6 状态管理

* Widget管理⾃⼰的state。 
* ⽗widget管理⼦widget状态。 
* 混合管理（⽗widget和⼦widget都管理状态）。

原则：

* ⽤户数据，如复选框的选中状态、滑块的位置，则该状态最好由⽗widget管理。 

* 有关界⾯外观效果的，例如颜⾊、动画，那么状态最好由 widget 本身来管理。 

* 某⼀个状态是不同widget共享的则最好由它们共同的⽗widget管理。

## 7 全局状态管理

例如语言变化。

* 实现⼀个全局的事件总线。
* 使⽤ **redux** 全局状态包。

## 8 Flutter widget 库介绍

* Text：带格式的文本
* Row、Column：在⽔平（Row）和垂直（Column）⽅向上创建灵活的 布局
* Stack：允许⼦ widget 堆叠， 你可以使⽤ Positioned 来定位他们相对于 Stack 的上下左右四条边的位置。
* Container：矩形视觉元素