## 1 反射（Reflect）

运行期间，获取类的信息，进行一些操作。

* 运行时构造类的对象。
* 运行时获取类的成员变量和方法。
* 运行时调用对象的方法（属性）。

## 2 Class 类

Class 类封装了类的所有信息。

```java
//1.类名.class -> Person.class
//2.对象.getClass() -> person.getClass()
//3.Class.forName(类全名) -> Class.forName("com.yoyiyi.test.Person")
```

## 3 Class 常用方法

Person.java

```java
public class Person {
    String name;
    private int age;

    public Person(String name, int age) {
        super();
        this.name = name;
        this.age = age;
        System.out.println("有参数构造器");
    }

    public Person() {
        super();
        System.out.println("无参数构造器");
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    private void privateMethod() {
        System.out.println("私有方法");
    }
}
```



```java
public class TestReflec {
    public static void main(String[] args) throws Exception {
        Class<Person> clazz = (Class<Person>) Class.forName("demo02.Person");

        /***1.构造器**/
        //获取所有的构造器
        Constructor<Person>[] constructors = 
            (Constructor<Person>[]) clazz.getConstructors();
        for (Constructor<Person> c : constructors) {
            System.out.println(c);
        }

        //获取某一个构造器
        Constructor<Person> constructor = clazz.getConstructor(String.class, int.class);

        //创建对象
        constructor.newInstance("Jack", 89);

        /**2.方法**/
        //获取类所有方法，包括父类，私有方法不能获取到
        Method[] methods = clazz.getMethods();
        for (Method method : methods) {
            System.out.println(method.getName());
        }

        //获取当前类所有方法，包括私有方法
        Method[] methods1 = clazz.getDeclaredMethods();
        for (Method method : methods1) {
            System.out.println(method.getName());
        }

        //获取指定方法
        Method setName = clazz.getDeclaredMethod("setName", String.class);
        Method setAge = clazz.getDeclaredMethod("setAge", int.class);
        System.out.println(setName.getName());
        System.out.println(setAge.getName());

        //调用某一个方法
        Person person = clazz.newInstance();
        setAge.invoke(person, 89);
        System.out.println(person.getAge());


        /**3.属性**/
        //获取当前类的属性，不包括父类
        Field[] fields = clazz.getDeclaredFields();
        for (Field field : fields) {
            System.out.println(field.getName());
        }

        //获取当前类的指定属性
        Field name = clazz.getDeclaredField("name");
        System.out.println(name.getName());


        //获取属性的值
        Person person1 = new Person("Maria", 7);
        String s = (String) name.get(person1);
        System.out.println(s);

        //设置对象的值
        Person person2 = new Person();
        Field age = clazz.getDeclaredField("age");
        age.setAccessible(true); //私有属性，设置 setAccessible(true)
        age.set(person2, 5);
        System.out.println(person2.getAge());


        //获取当前类的指定私有属性
        Field age2 = clazz.getDeclaredField("age");
        age2.setAccessible(true);
        System.out.println(age2.getName());
    }
}
```

## 4 代理模式

为其他对象提供一种代理以控制对这个对象的访问（代理类相当于一个中介）。

![](../../asset/代理模式.png)

### 4.1 静态代理

```java
//ISeller.java
public interface ISeller {
    void sell();
}

//Factory.java
public class Factory implements ISeller {

    @Override
    public void sell() {
        System.out.println("厂家直销");
    }
}

//Daigou.java
public class Daigou implements ISeller {

    private ISeller seller;

    public Daigou(ISeller seller) {
       this.seller = seller;
    }

    @Override
    public void buy() {
        doBefore();
        //真正调用的持有的类的方法
        mSeller.sell();
        doAfter();
    }

    private void doBefore() {
        System.out.println("加价899");
    }

    private void doAfter() {
        System.out.println("提供售后");
    }
}

//TestProxy.java
public class TestProxy {
    public static void main(String[] args) {
        Factory factory = new Factory();
        Daigou daigou = new Daigou(factory);
        daigou.buy();
    }
}

//假如我们买一个面膜，找到代购，代购其实也是别处买的，代购加价 899 元卖给你，我们不直接和厂家发生关系，这种就是一个代理模型
```

代理模式可以在不修改被代理对象的基础上，通过扩展代理类，进行一些功能的附加与增强。值得注意的是，代理类和被代理类应该共同实现一个接口，或者是共同继承某个类。

但是有弊端，假如这人不仅不仅要面膜，还要核导弹、航空母舰等等，就创建了许多代理类。

### 4.2 动态代理

```java

//ISeller.java
public interface ISeller {
    void sell();
}

//SuperDaigou.java
public class SuperDaigou implements ISeller {
    @Override
    public void sell() {
        System.out.println("超级代购");
    }
}

//ProxyHandler.java
public class ProxyHandler implements InvocationHandler {

    //声明目标对象
    private ISeller target;

    public ProxyHandler(ISeller target) {
        this.target = target;
    }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        doBefore();
        Object invoke = method.invoke(target, args);
        doAfter();
        return invoke;
    }

    //得到代理对象
    public Object getProxyInstance() {
        return Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), this);
    }

    private void doBefore() {
        System.out.println("加价899");
    }

    private void doAfter() {
        System.out.println("提供售后");
    }
}

public class TestProxy {

    public static void main(String[] args) {
        SuperDaigou superDaigou = new SuperDaigou();
        ProxyHandler handler = new ProxyHandler(superDaigou);
        //增强原来的方法
        ISeller seller = (ISeller) handler.getProxyInstance();
        seller.sell();
    }
}
```

由于使用了反射，效率比较低。