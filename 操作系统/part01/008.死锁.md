## 1 死锁的概念
多个进程因为竞争资源而造成互相等待。

## 2 死锁产生的条件

### 2.1 互斥条件
进程获取到资源具有排他性，一旦占用，其他进程只能等待。

### 2.2 不剥夺条件
进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放。

### 2.3 请求并保持条件
指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放。（吃着碗里瞧着锅里）

### 2.4 循环等待条件
指在发生死锁时，必然存在一个进程——资源的环形链，即进程集合{P0，P1，P2，···，Pn}中的P0正在等待一个P1占用的资源；P1正在等待P2占用的资源，……，Pn正在等待已被P0占用的资源。

## 3 死锁的处理策略

### 3.1 预防死锁
1. 破坏互斥条件：有些资源必须互斥使用，无法破坏互斥条件（例如打印机）。
2. 破坏不剥夺条件：增加系统开销，降低吞吐量。
3. 破坏请求和保持条件：采用预先静态分配方法，一次性申请所有需要资源，严重浪费系统资源，还肯导致饥饿现象。
4. 破坏循环等待条件：采用顺序资源分配方法，浪费系统资源，造成编程的不便。

### 3.2 避免死锁
1. 安全状态：能找到一个分配资源的序列让所有进程都顺序完成。
2. 银行家算法：采用预分配策略检查分配完成时系统是否处在安全状态。

### 3.3 检测死锁
利用死锁定理化简资源分配图以检测死锁的存在。

### 3.4 解除死锁
1. 资源剥夺法：挂起某些死锁的进程，让其他进程继续推进。
2. 撤销进程法：强制撤销部分，甚至全部，并剥夺资源。
3. 进程回退法：让一个或多个进程回退到足以回避死锁的地步。