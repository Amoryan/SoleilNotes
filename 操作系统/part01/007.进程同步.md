## 1 进程同步的基本概念

### 1.1 临界资源
临界资源：一次仅允许一个进程使用的资源（必须互斥进行）。

临界区：访问临界资源的代码。

### 1.2 同步
也称直接制约关系，为了完成任务的多个线程进程，需要协调它们工作次序等待。

### 1.3 互斥
也称间接制约关系，当一个进程使用临界资源，其他进程需要等待。

同步机制遵循以下准则：
1. 空闲等待
2. 忙则等待
3. 有限等待
4. 让权等待

## 2 实现临界区互斥的方法
### 2.1 软件实现
#### 2.1.1 单标志法（违背空闲等待原则）
该算法设置一个公用整型变量 turn ，用于指示被允许进入临界区的进程编号，即，若turn = 0 ，则允许p0 进程进入临界区。

该算法可确保每次只允许一个进程进入临界区，但两个进程必须交换进入临界区，如果某个进程不再进入临界了，那么另一个进程也将无法进入临界区（违背“空闲让进”）。这样很容易造成资源利用不充分。

#### 2.1.2 双标志法先检查（违背忙则等待原则）
 该算法的基本思想是在每一个进程访问临界区资源之前，先查看一下临界区资源是否正被访问，若正被访问，该进程需等待；否则，进程才进入自己的临界区。为此，设置一个数据  flag[ i ] ，如第i个元素值为 FALSE ，表示Pi进程未进入临界区，值为 TRUE ，表示Pi进程进入临界区。

#### 2.1.3 双标志法后检查（会导致饥饿现象）
算法二是先检查对方进程状态标志后，再置自己的标志，由于在检查和放置中可插入另一个进程到达时的检测操作，会造成两个进程在分别检查后，同时进入临界区。为此，算法三采用先设置自己标志为  TRUE  后，再检测对方状态标志，若对方标志位 TRUE，则进程等待，否则进入临界区。

#### 2.1.4 Peterson's Algorithm（皮特森算法：单标志法和双标志法后检查的结合）
为了防止两个进程为进入临界区而无限期等待，又设置变量 turn，每个进程在设置自己标志后再设置 turn 标志。这时，再同时检测另一个进程状态标志和不允许进入标志，这样可以保证当进程同时要求进入临界区，只允许一个进程进入临界区。

### 2.2 硬件实现

 计算机提供了特殊的硬件指令，允许对一个字中的内容进行检测和修正，或者是对两个字的内容进行交换等。通过硬件支持实现临界区问题的低级方法或称为 **元方法**。

#### 2.2.1 中断屏蔽方法

当一个进程正在使用处理机执行它的临界区代码时，要防止其他进程再进入其临界区访问的最简单的方法是：禁止一切中断发生，或称之为屏蔽中断关中断。

#### 2.2.2 硬件指令方法：设立原子操作指令

TestAndSet 指令：这条指令是**原子操作**，即执行该代码时不允许被中断。其功能是：读出指定标志后把该标志设置为真。

#### 2.2.3 信号量
解决互斥和同步问题，只能被 wait(S) 和 signal(S) 访问。记作，P 操作、V 操作。本身是一个计数器，使用P，V两个操作来实现计数的减与加，当计数不大于 0 时，则进程进入睡眠状态，它用于为多个进程提供共享数据对象的访问。

## 3 管程
管程是由局部于自己的若干公共变量及其说明和所有访问这些公共变量的过程所组成的软件模块。

目的：

1. 把分散在各进程中的临界区集中起来进行管理；
2. 防止进程有意或无意的违法同步操作；
3. 便于用高级语言来书写程序，也便于程序正确性验证。

## 4 经典同步问题

### 4.1 生产者与消费者问题
问题描述：一组生产者进程和一组消费者进程共享一块初始为空，大小确定的缓冲区，只有当缓冲区为满时，生产者进程才可以把信息放入缓冲区，否则就要等待；只有缓存区不为空时，消费者进程才能从中取出消息，否则就要等待。缓冲区一次只能一个进程访问（临界资源）。

问题分析：生产者与消费者进程对缓冲区的访问是互斥关系，而生产者与消费者本身又存在同步关系，即必须生成之后才能消费。因而对于缓冲区的访问设置一个互斥量，再设置两个信号量一个记录空闲缓冲区单元，一个记录满缓冲区单元来实现生产者与消费者的同步。

```c
semaphore mutex=1;
semaphore full=0;      //满缓冲区单元
semaphore empty=N;    //空闲缓冲区单元

prodecer()
{
    while(1)
    {
          P(empty);          
          P(mutex);
          add_source++;
          V(mutex);
          V(full);      
    }    
}        

consumer()
{
    while(1)
   {
         P(full);
         P(mutex);
         add_source--;
         V(mutex);
         V(empty);     
    }    
}
```

### 4.2 读者与写者问题

问题描述：有读者与写者两个并发进程共享一个数据，两个或以上的读进程可以访问数据，但是一个写者进程访问数据与其他进程都互斥。

问题分析：读者与写者是互斥关系，写者与写者是互斥关系，读者与读者是同步关系。因而需要一个互斥量实现读与写和写与写互斥，一个读者的访问计数和实现对计数的互斥。

```c
//1.读者优先
//读者优先，只要有读者源源不断，写者就得不到资源。容易造成写者饥饿。
//读者优先

int count=0;
semaphore mutex=1;    //读者计数锁
semaphore rw=1;       //资源访问锁

writer()
{
    while(1)
    {
        P(rw);
        writing sth;
        V(rw);
    }
}

reader()
{
    while(1)
    {
        P(mutex);
        if(count==0)
            P(rw);
        count++;
        V(mutex);
        reading sth;
        P(mutex);
        count--;
        if(count==0)
            V(rw);
        V(mutex)；
    }
}

//2.读写公平
//读者与写者公平抢占资源，但是只要之前已经排队的读者，就算写者获取的资源，也要等待所有等待的读者进程结束。
//读写公平
int count=0；
semaphore mutex=1;    //读者计数锁
semaphore rw=1;       //资源访问锁
semaphore w=1;        //读写公平抢占锁
writer()
{
    while(1)
    {
        P(w);
        P(rw);
        writing sth;
        V(rw);
        V(w);
    }
}

reader()
{
    while(1)
    {
        P(w);
        P(mutex);
        if(count==0)
            P(rw);
        count++;
        V(mutex);
        V(w);
        reading sth;
        P(mutex);
        count--;
        if(count==0)
            V(rw);
        V(mutex);
    }
}

//3.写者优先
//写者优先，只要写者源源不断，读者就得不到资源，但是在这之前已经排队的的读者进程依然可以优先获得资源，在这之后则等待所有写者进程的结束。这种也易造成读者饥饿。
//写者优先
int write_count=0;         //写计数
int count=0;               //读计数
semaphore w_mutex=1;     //读计数时锁
semaphore r_mutex=1;    //写计数时锁
semaphore rw=1;            //写优先锁
semaphore source=1;        //资源访问锁

writer()
{
    while(1)
    {
        P(w_mutux);
        if(write_count==0)
            P(rw);        //获得则只要有写进程进来就不释放
        write_count++;
        V(w_mutux)

        P(resouce);        //写时互斥必须加资源独占的锁
        writing sth;
        V(resouce);

        P(w_mutux);
        write_count--;
        if(write_count==0)
            V(rw);
        V(w_mutux);
    }
}

reader()
{
    while(1)
    {
        P(rw);            //使用了立即释放
        P(r_mutex);
        if(count==0)
            P(resouce);
        count++;
        V(r_mutex);
        V(rw);

        reading sth;

        P(r_mutex);
        count--;
        if(count==0)
            V(resouce);
        V(r_mutex);
    }
}
```

### 4.3 **哲学家就餐问题**

问题描述：一张圆桌上坐着五名哲学家，每两名哲学家之间的桌子摆一根筷子，哲学家只有同时拿起左右两根筷子时才可以用餐，用餐完了筷子放回原处。

问题分析：这里五名哲学家就是五个进程，五根筷子是需要获取的资源。可以定义互斥数组用于表示五根筷子的互斥访问，为了防止哲学家个取一根筷子出现死锁，需要添加一定的限制条件。一种方法是限制仅当哲学家左右筷子均可以用时，才拿起筷子，这里需要一个互斥量来限制获取筷子不会出现竞争。

问题解决：一次仅能一个哲学家拿起筷子，效率比较低。

```c
semaphore chopstick[5]={1,1,1,1,1};
semaphore mutex=1;
pi()
{
    while(1)
    {
        P(mutex);
        P(chopstick[i]);
        P(chopstick[(i+1)%5]);
        V(mutex);

        eating;

        V(chopstick[i]);
        V(chopstick[(i+1)%5]);
    }
}
```

